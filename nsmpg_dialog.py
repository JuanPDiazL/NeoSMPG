# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NSMPGDialog
                                 A QGIS plugin
 New implementation of SMPG
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Juan Pablo Diaz Lombana
        email                : email.not@defined.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
import json
import traceback
# import cProfile
# import pstats

from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import (
    QDialog,
    QMessageBox,
    QFileDialog,
    QGroupBox,
    QPushButton,
    QLineEdit,
    QCheckBox,
    QComboBox,
    QRadioButton,
    QLabel,
)

from qgis.core import (
    QgsTask, 
    QgsTaskManager,
)

from .map_settings_dialog import MapSettingsDialog
from .year_selection_dialog import YearSelectionDialog
from .progress_dialog import ProgressDialog

from .nsmpgCore.parsers.CSVParser import parse_csv
from .nsmpgCore.structures import Dataset
from .nsmpgCore.utils import (
    Parameters, Properties, define_seasonal_dict, parse_timestamps, 
    get_properties_validated_year_list
    )
from .nsmpgCore.pyqgis_utils import (
    load_layer_file,
    join_layers,
    add_to_project,
    apply_default_symbology,
    rename_layer
)
    
from .nsmpgCore.exporters.WebExporter import export_to_web_files
from .nsmpgCore.exporters.CSVExporter import export_to_csv_files
from .nsmpgCore.exporters.ImageExporter import export_to_image_files
from .nsmpgCore.exporters.ParameterExporter import export_parameters
from .nsmpgCore.exporters.QGISExporter import generate_layers_from_csv

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'nsmpg_dialog_base.ui'))


class NSMPGDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(NSMPGDialog, self).__init__(parent)
        self.setupUi(self)

        # task manager object that executes the processing tasks in threads.
        self.task_manager = QgsTaskManager(self) 

        self.year_selection_dialog = YearSelectionDialog(self)
        self.progress_dialog = ProgressDialog(self)
        self.map_settings_dialog = MapSettingsDialog(self)

        # input group
        self.loadFileButton: QPushButton
        self.datasetInputLineEdit: QLineEdit
        self.importParametersButton: QPushButton
        self.importParametersLineEdit: QLineEdit
        
        self.climatologyStartComboBox: QComboBox
        self.climatologyEndComboBox: QComboBox

        self.crossYearsCheckBox: QCheckBox
        self.seasonStartComboBox: QComboBox
        self.seasonEndComboBox: QComboBox

        self.customYearsRadioButton: QRadioButton
        self.similarYearsRadioButton: QRadioButton
        self.similarYearsComboBox: QComboBox
        self.usePearsonCheckBox: QCheckBox
        self.selectYearsButton: QPushButton

        self.observedDataRadioButton: QRadioButton
        self.forecastRadioButton: QRadioButton

        self.exportWebCheckBox: QCheckBox
        self.exportImagesCheckBox: QCheckBox
        self.exportStatsCheckBox: QCheckBox
        self.exportParametersCheckBox: QCheckBox
        self.mappingButton: QPushButton

        self.datasetInfoLabel: QLabel

        self.processButton: QPushButton

        self.mappingButton.clicked.connect(self.mapping_button_event)
        self.exportStatsCheckBox.stateChanged.connect(self.export_stats_cb_changed_event)

        self.crossYearsCheckBox.stateChanged.connect(self.cross_years_cb_changed_event)
        self.customYearsRadioButton.toggled.connect(self.year_selection_rb_event)
        self.similarYearsRadioButton.toggled.connect(self.year_selection_rb_event)
        self.selectYearsButton.clicked.connect(self.select_years_btn_event)

        self.loadFileButton.clicked.connect(self.load_file_btn_event)
        self.importParametersButton.clicked.connect(self.import_parameters_btn_event)
        self.processButton.clicked.connect(self.process_btn_event)

    def get_parameters_from_widgets(self):
        selected_years = None
        if self.customYearsRadioButton.isChecked():
            selected_years = self.year_selection_dialog.selected_years
        else:
            selected_years = self.similarYearsComboBox.currentText()

        return {
            "climatology_start": self.climatologyStartComboBox.currentText(),
            "climatology_end": self.climatologyEndComboBox.currentText(),
            "season_start": self.seasonStartComboBox.currentText(),
            "season_end": self.seasonEndComboBox.currentText(),
            "cross_years": self.crossYearsCheckBox.isChecked(),
            "selected_years": selected_years,
            "is_forecast": self.forecastRadioButton.isChecked(),
            "use_pearson": self.usePearsonCheckBox.isChecked(),
            "output_web": self.exportWebCheckBox.isChecked(),
            "output_images": self.exportImagesCheckBox.isChecked(),
            "output_stats": self.exportStatsCheckBox.isChecked(),
            "output_parameters": self.exportParametersCheckBox.isChecked(),
            "mapping_attributes": self.map_settings_dialog.settings['selected_fields'],
        }

    def update_fields(self, parameters: Parameters):
        self.crossYearsCheckBox.setChecked(parameters.cross_years)
        year_ids = get_properties_validated_year_list(self.dataset_properties, self.crossYearsCheckBox.isChecked())
        sub_season_ids = define_seasonal_dict(self.crossYearsCheckBox.isChecked())

        self.climatologyStartComboBox.setEnabled(True)
        self.climatologyStartComboBox.clear()
        self.climatologyStartComboBox.addItems(year_ids)
        if parameters.climatology_start is None:
            self.climatologyStartComboBox.setCurrentText(year_ids[0])
        else:
            self.climatologyStartComboBox.setCurrentText(parameters.climatology_start)
        self.climatologyEndComboBox.setEnabled(True)
        self.climatologyEndComboBox.clear()
        self.climatologyEndComboBox.addItems(year_ids)
        if parameters.climatology_end is None:
            self.climatologyEndComboBox.setCurrentText(year_ids[-1])
        else:
            self.climatologyEndComboBox.setCurrentText(parameters.climatology_end)

        self.seasonStartComboBox.setEnabled(True)
        self.seasonStartComboBox.clear()
        self.seasonStartComboBox.addItems(sub_season_ids)
        if parameters.season_start is None:
            self.seasonStartComboBox.setCurrentText(sub_season_ids[0])
        else:
            self.seasonStartComboBox.setCurrentText(parameters.season_start)
        self.seasonEndComboBox.setEnabled(True)
        self.seasonEndComboBox.clear()
        self.seasonEndComboBox.addItems(sub_season_ids)
        if parameters.season_end is None:
            self.seasonEndComboBox.setCurrentText(sub_season_ids[-1])
        else:
            self.seasonEndComboBox.setCurrentText(parameters.season_end)

        self.importParametersLineEdit.setEnabled(True)
        self.importParametersButton.setEnabled(True)
        self.customYearsRadioButton.setEnabled(True)
        self.similarYearsRadioButton.setEnabled(True)
        self.crossYearsCheckBox.setEnabled(True)
        self.processButton.setEnabled(True)

        if isinstance(parameters.selected_years, list) or parameters.selected_years is None:
            self.customYearsRadioButton.setChecked(True)
            self.selectYearsButton.setEnabled(True)
            self.similarYearsComboBox.setEnabled(False)
            self.usePearsonCheckBox.setEnabled(False)
        self.year_selection_dialog.updateYearsList(year_ids)
        self.year_selection_dialog.selected_years = parameters.selected_years
        self.year_selection_dialog.update_selection()

        self.similarYearsComboBox.clear()
        self.similarYearsComboBox.addItems([str(y) for y in range(1, self.dataset_properties.season_quantity+1)])
        if isinstance(parameters.selected_years, str):
            self.similarYearsRadioButton.setChecked(True)
            self.similarYearsComboBox.setEnabled(True)
            self.similarYearsComboBox.setCurrentText(parameters.selected_years)
            self.usePearsonCheckBox.setEnabled(True)
            self.selectYearsButton.setEnabled(False)
        self.usePearsonCheckBox.setChecked(parameters.use_pearson)

        self.observedDataRadioButton.setEnabled(True)
        self.forecastRadioButton.setEnabled(True)
        if parameters.is_forecast: self.forecastRadioButton.setChecked(True)
        else: self.observedDataRadioButton.setChecked(True)

        self.exportWebCheckBox.setEnabled(True)
        self.exportWebCheckBox.setChecked(parameters.output_web)
        self.exportImagesCheckBox.setEnabled(True)
        self.exportImagesCheckBox.setChecked(parameters.output_images)
        self.exportStatsCheckBox.setEnabled(True)
        self.exportStatsCheckBox.setChecked(parameters.output_stats)
        self.exportParametersCheckBox.setEnabled(True)
        self.exportParametersCheckBox.setChecked(parameters.output_parameters)
        self.mappingButton.setEnabled(parameters.output_stats)
        self.map_settings_dialog.settings['selected_fields'] = parameters.mapping_attributes

    # function that reads the dataset from a file.
    def load_file_btn_event(self): 
        # path reading
        temp_dataset_source = QFileDialog.getOpenFileName(self, 'Open dataset file', None, "CSV files (*.csv)")[0]
        if temp_dataset_source == "":
            QMessageBox.warning(self, "Warning", 
                                'No dataset was selected.', 
                                QMessageBox.Ok)
            return
        self.selected_source = temp_dataset_source
        self.dataset_source_path = os.path.normpath(os.path.dirname(self.selected_source))
        self.dataset_filename = ''.join(os.path.basename(self.selected_source).split('.')[:-1])

        # parse dataset
        try:
            self.parsed_dataset, self.col_names, has_duplicates = parse_csv(self.selected_source)
            self.dataset_properties = Properties(parse_timestamps(self.col_names))
        except Exception as e:
            QMessageBox.critical(self, "Error", f'The dataset could not be read.\n\n{str(e)}\n\n{traceback.format_exc()}', QMessageBox.Ok)
            return
        if has_duplicates:
            QMessageBox.warning(self, "Warning", 
                                'Duplicated place names have been found.\nThe program might produce unexpected results.', 
                                QMessageBox.Ok)

        # set form fields content from data
        self.datasetInputLineEdit.setText(self.selected_source)

        self.update_fields(Parameters())
        self.year_selection_dialog.selected_years = self.dataset_properties.year_ids
        self.update_dialog_info(self.dataset_properties)

    # function to allow the computation of the required data, such as accumulation, ensemble, stats, percentiles, etc
    def process_btn_event(self):
        # invalid input handling
        if self.climatologyStartComboBox.currentIndex() > self.climatologyEndComboBox.currentIndex():
            QMessageBox.critical(self, "Error", 
                                 'The start of the climatology must be before the end of the climatology', 
                                 QMessageBox.Ok)
            return
        if self.seasonStartComboBox.currentIndex() > self.seasonEndComboBox.currentIndex():
            QMessageBox.critical(self, "Error", 
                                 'The start of the season must be before the end of the season.', 
                                 QMessageBox.Ok)
            return

        # path reading
        self.destination_path = os.path.normpath(QFileDialog.getExistingDirectory(self, 'Save results', self.dataset_source_path))
        if self.destination_path == ".":
            QMessageBox.warning(self, "Warning", 
                                'No export folder was selected.', 
                                QMessageBox.Ok)
            return
        
        # ask for creating subfolder
        dlg = QMessageBox.information(self, "Create new folder?", 
                            f'Do you want to create a folder for the report files?\nThe folder {self.dataset_filename} at the path {self.destination_path} will be created.', 
                            QMessageBox.Yes, QMessageBox.No)
        if dlg == QMessageBox.Yes:
            self.destination_path = os.path.join(self.destination_path, self.dataset_filename)
        
        # computation with parameters given from GUI
        parameters = Parameters(self.get_parameters_from_widgets())
        self.structured_dataset = Dataset(self.dataset_filename, self.parsed_dataset, self.col_names, parameters)
        
        self.progress_dialog.show()
        # add selected output tasks to a list of tasks
        long_tasks: list[TaskHandler] = []
        if self.exportStatsCheckBox.isChecked():
            csv_task = TaskHandler('CSV Export Task', export_to_csv_files, self.destination_path, self.structured_dataset)
            long_tasks.append(csv_task)
            if len(self.map_settings_dialog.settings['selected_fields']) != 0:
                map_task = TaskHandler(
                    'Summary Mapping Task',
                    generate_layers_from_csv, 
                    self.map_settings_dialog.settings,
                    self.map_settings_dialog.map_layer,
                    # the last argument will be passed by the LongTaskHandler after csv_task finishes
                )
                map_task.setDependentLayers([self.map_settings_dialog.map_layer])
                csv_task.addNextTask(map_task)
                long_tasks.append(map_task)

        if self.exportWebCheckBox.isChecked():
            long_tasks.append(TaskHandler(
                'Web Report Export Task', 
                export_to_web_files, 
                self.destination_path, 
                self.structured_dataset
            ))

        if self.exportParametersCheckBox.isChecked():
            long_tasks.append(TaskHandler(
                'Parameters Export Task', 
                export_parameters, 
                self.destination_path, 
                self.structured_dataset
                ))
            
        if self.exportImagesCheckBox.isChecked():
            long_tasks.append(TaskHandler(
                'Static Reports Export Task', 
                export_to_image_files, 
                self.destination_path, 
                self.structured_dataset
                ))
        
        self.renderTime = time.perf_counter()
        for task in long_tasks:
            self.task_manager.addTask(task)
        self.task_manager.allTasksFinished.connect(lambda: self.progress_dialog.finish_wait(self.task_manager, long_tasks))

    def import_parameters_btn_event(self) -> None:
        # path reading
        temp_parameters_source = QFileDialog.getOpenFileName(self, 'Open parameters file', None, "JSON files (*.json)")[0]
        if temp_parameters_source == "": 
            QMessageBox.warning(self, "Warning", 
                                'No dataset was selected.', 
                                QMessageBox.Ok)
            return
        self.parameters_source = temp_parameters_source
        try:
            with open(self.parameters_source, 'r') as json_file:
                parameters = json.load(json_file)
            parameters = Parameters(parameters)
        except Exception as e:
            QMessageBox.critical(self, 'Error', f'Could not load parameters from {self.parameters_source}.\n\n{str(e)}\n\n{traceback.format_exc()}')
            return
        self.importParametersLineEdit.setText(self.parameters_source)
        self.update_fields(parameters)

    def cross_years_cb_changed_event(self):
        parameters = Parameters(
            {
                **self.get_parameters_from_widgets(),
                'climatology_start': None,
                'climatology_end': None,
                'season_start': None,
                'season_end': None,
                'selected_years': None,
                'cross_years': self.crossYearsCheckBox.isChecked(),
            }
        )
        self.update_fields(parameters)

    def year_selection_rb_event(self):
        if self.customYearsRadioButton.isChecked():
            self.selectYearsButton.setEnabled(True)
            self.similarYearsComboBox.setEnabled(False)
            self.usePearsonCheckBox.setEnabled(False)
        elif self.similarYearsRadioButton.isChecked():
            self.similarYearsComboBox.setEnabled(True)
            self.usePearsonCheckBox.setEnabled(True)
            self.selectYearsButton.setEnabled(False)

    def export_stats_cb_changed_event(self):
        self.mappingButton.setEnabled(self.exportStatsCheckBox.isChecked())

    def select_years_btn_event(self):
        self.year_selection_dialog.show()

    def mapping_button_event(self):
        self.map_settings_dialog.show()

    def update_dialog_info(self, dataset_properties: Properties):
        dg_text = \
f'''First Year: {dataset_properties.year_ids[0]}
Last Year: {dataset_properties.year_ids[-1]}
Current Year: {dataset_properties.current_season_id}
Dekads in Current Year: {dataset_properties.current_season_length}'''
        self.datasetInfoLabel.setText(dg_text)

class TaskHandler(QgsTask):
    def __init__(self, description, fn, *args, nextTask=None, dependentLayers=[], **kwargs):
        super().__init__(description, QgsTask.CanCancel)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.title = description
        self.result = None
        self.exception = None
        self.debug = False
        self.time = 0

        self.setDependentLayers(dependentLayers)
        self.nextTask = None
        if nextTask is not None:
            self.addNextTask(nextTask)

    def run(self):
        if self.debug: print(f'{self.description()} started')
        if self.isCanceled():
            return False
        try:
            self.result = self.fn(*self.args)
            return True
        except Exception as e:
            self.exception = e
            return False

    def finished(self, result):
        # when task completed successfully
        if result:
            ...
            if self.nextTask is not None:
                self.nextTask.args =  (*self.nextTask.args, self.result)
            self.time = self.elapsedTime()
            if self.debug: print(f'{self.description()} completed')
            return
        # when task did not complete successfully
        if self.exception is not None:
            if self.debug: print(f'{self.description()} raised an exeception')
            if self.nextTask is not None:
                self.nextTask.cancel()
                self.nextTask.unhold()
            return
        if self.debug: print(f'{self.description()} terminated')

    def cancel(self):
        # do something before cancelling
        if self.debug: print(f'{self.description()} got cancelled')
        if self.nextTask is not None:
            self.nextTask.cancel()
            self.nextTask.unhold()

        super().cancel()

    def addNextTask(self, task: QgsTask):
        self.nextTask = task
        task.hold()
        super().taskCompleted.connect(task.unhold)